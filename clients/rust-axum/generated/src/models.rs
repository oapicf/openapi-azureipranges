#![allow(unused_qualifications)]

use http::HeaderValue;
use validator::Validate;

#[cfg(feature = "server")]
use crate::header;
use crate::{models, types::*};

      
    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))] 
    pub struct GetAzureIpRangesServiceTagsPublicCloudPathParams {
            /// The version of the JSON file to be retrieved in the format YYYYMMDD, e.g. 20240506
                pub version: String,
    }







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Change {
/// The number associated with the change.
    #[serde(rename = "changeNumber")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub change_number: Option<i32>,

/// The cloud environment.
    #[serde(rename = "cloud")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cloud: Option<String>,

    #[serde(rename = "values")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub values: Option<Vec<models::Value>>,

}


impl Change {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> Change {
        Change {
            change_number: None,
            cloud: None,
            values: None,
        }
    }
}

/// Converts the Change value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for Change {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.change_number.as_ref().map(|change_number| {
                [
                    "changeNumber".to_string(),
                    change_number.to_string(),
                ].join(",")
            }),


            self.cloud.as_ref().map(|cloud| {
                [
                    "cloud".to_string(),
                    cloud.to_string(),
                ].join(",")
            }),

            // Skipping values in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Change value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Change {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub change_number: Vec<i32>,
            pub cloud: Vec<String>,
            pub values: Vec<Vec<models::Value>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Change".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "changeNumber" => intermediate_rep.change_number.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "cloud" => intermediate_rep.cloud.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "values" => return std::result::Result::Err("Parsing a container in this style is not supported in Change".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing Change".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Change {
            change_number: intermediate_rep.change_number.into_iter().next(),
            cloud: intermediate_rep.cloud.into_iter().next(),
            values: intermediate_rep.values.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Change> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Change>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Change>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Change - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<Change> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Change as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Change - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Value {
/// The name of the value.
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

/// The unique identifier of the value.
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "properties")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub properties: Option<models::ValueProperties>,

}


impl Value {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> Value {
        Value {
            name: None,
            id: None,
            properties: None,
        }
    }
}

/// Converts the Value value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for Value {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.id.as_ref().map(|id| {
                [
                    "id".to_string(),
                    id.to_string(),
                ].join(",")
            }),

            // Skipping properties in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Value value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Value {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub id: Vec<String>,
            pub properties: Vec<models::ValueProperties>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Value".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "properties" => intermediate_rep.properties.push(<models::ValueProperties as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing Value".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Value {
            name: intermediate_rep.name.into_iter().next(),
            id: intermediate_rep.id.into_iter().next(),
            properties: intermediate_rep.properties.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Value> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Value>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Value>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Value - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<Value> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Value as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Value - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}







#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ValueProperties {
/// The number associated with the change.
    #[serde(rename = "changeNumber")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub change_number: Option<i32>,

/// The region associated with the value.
    #[serde(rename = "region")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub region: Option<String>,

/// The ID of the region.
    #[serde(rename = "regionId")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub region_id: Option<i32>,

/// The platform associated with the value.
    #[serde(rename = "platform")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub platform: Option<String>,

/// The system service associated with the value.
    #[serde(rename = "systemService")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub system_service: Option<String>,

/// The address prefixes associated with the value.
    #[serde(rename = "addressPrefixes")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub address_prefixes: Option<Vec<String>>,

/// The network features associated with the value.
    #[serde(rename = "networkFeatures")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub network_features: Option<Vec<String>>,

}


impl ValueProperties {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> ValueProperties {
        ValueProperties {
            change_number: None,
            region: None,
            region_id: None,
            platform: None,
            system_service: None,
            address_prefixes: None,
            network_features: None,
        }
    }
}

/// Converts the ValueProperties value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ValueProperties {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.change_number.as_ref().map(|change_number| {
                [
                    "changeNumber".to_string(),
                    change_number.to_string(),
                ].join(",")
            }),


            self.region.as_ref().map(|region| {
                [
                    "region".to_string(),
                    region.to_string(),
                ].join(",")
            }),


            self.region_id.as_ref().map(|region_id| {
                [
                    "regionId".to_string(),
                    region_id.to_string(),
                ].join(",")
            }),


            self.platform.as_ref().map(|platform| {
                [
                    "platform".to_string(),
                    platform.to_string(),
                ].join(",")
            }),


            self.system_service.as_ref().map(|system_service| {
                [
                    "systemService".to_string(),
                    system_service.to_string(),
                ].join(",")
            }),


            self.address_prefixes.as_ref().map(|address_prefixes| {
                [
                    "addressPrefixes".to_string(),
                    address_prefixes.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),


            self.network_features.as_ref().map(|network_features| {
                [
                    "networkFeatures".to_string(),
                    network_features.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(","),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ValueProperties value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ValueProperties {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub change_number: Vec<i32>,
            pub region: Vec<String>,
            pub region_id: Vec<i32>,
            pub platform: Vec<String>,
            pub system_service: Vec<String>,
            pub address_prefixes: Vec<Vec<String>>,
            pub network_features: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ValueProperties".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "changeNumber" => intermediate_rep.change_number.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "region" => intermediate_rep.region.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "regionId" => intermediate_rep.region_id.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "platform" => intermediate_rep.platform.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "systemService" => intermediate_rep.system_service.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "addressPrefixes" => return std::result::Result::Err("Parsing a container in this style is not supported in ValueProperties".to_string()),
                    "networkFeatures" => return std::result::Result::Err("Parsing a container in this style is not supported in ValueProperties".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ValueProperties".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ValueProperties {
            change_number: intermediate_rep.change_number.into_iter().next(),
            region: intermediate_rep.region.into_iter().next(),
            region_id: intermediate_rep.region_id.into_iter().next(),
            platform: intermediate_rep.platform.into_iter().next(),
            system_service: intermediate_rep.system_service.into_iter().next(),
            address_prefixes: intermediate_rep.address_prefixes.into_iter().next(),
            network_features: intermediate_rep.network_features.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ValueProperties> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ValueProperties>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ValueProperties>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ValueProperties - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ValueProperties> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ValueProperties as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ValueProperties - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}



